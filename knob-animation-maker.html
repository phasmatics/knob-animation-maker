<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Knob Animation Tool (Prototype)</title>
  <style>
    :root { --panel-bg:#111; --panel-fg:#eee; --muted:#aaa; --accent:#7bd; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; background:#0b0b0b; color:#eee; }
    .wrap { display:flex; flex-direction:column; min-height:100vh; }
    .top {
      flex: 1 1 auto;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 16px 12px;
      background: linear-gradient(#0b0b0b, #101010);
    }
    canvas {
      width: min(1200px, 96vw);
      height: min(520px, 56vh);
      background: transparent; /* 透過 */
      border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px;
    }

    .bottom {
      flex: 0 0 auto;
      background: var(--panel-bg);
      border-top: 1px solid rgba(255,255,255,.08);
      padding: 14px 12px 18px;
    }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row + .row { margin-top:10px; }

    button {
      background: #1b1b1b;
      color: var(--panel-fg);
      border: 1px solid rgba(255,255,255,.14);
      padding: 9px 12px;
      border-radius: 10px;
      cursor:pointer;
    }
    button:hover { border-color: rgba(255,255,255,.28); }
    button.primary { background: #15222a; border-color: rgba(123,221,255,.35); }
    button.danger { background: #2a1515; border-color: rgba(255,120,120,.35); }
    button:disabled { opacity: .45; cursor: not-allowed; }

    input, select {
      background:#141414;
      color: var(--panel-fg);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 10px;
      padding: 8px 10px;
      outline:none;
    }
    input[type="number"] { width: 92px; }
    input[type="text"] { width: 220px; }
    input[type="checkbox"] { width:auto; }
    .small { width: 96px; }
    label { color: var(--muted); font-size: 12px; display:flex; flex-direction:column; gap:6px; }
    .label-inline { flex-direction:row; align-items:center; gap:8px; }
    .knob-list { margin-top: 12px; display:flex; flex-direction:column; gap:10px; }
    .knob-card {
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
      background: rgba(255,255,255,.03);
    }
    .knob-card .header {
      display:flex; justify-content:space-between; align-items:center; margin-bottom: 10px;
    }
    .knob-card .title { font-weight: 650; }
    .hint { color: var(--muted); font-size: 12px; line-height:1.5; }
    .progress {
      height: 10px;
      background: rgba(255,255,255,.08);
      border-radius: 999px;
      overflow:hidden;
      width: 260px;
      border: 1px solid rgba(255,255,255,.10);
    }
    .progress > div {
      height:100%;
      width:0%;
      background: rgba(123,221,255,.65);
      transition: width .08s linear;
    }
    .spacer { flex:1; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <canvas id="c"></canvas>
  </div>

  <div class="bottom">
    <div class="row">
      <button class="primary" id="playBtn">▶ 再生</button>
      <button id="stopBtn">■ 停止</button>
      <button id="resetBtn">↺ リセット</button>

      <div class="spacer"></div>

      <label>アニメ秒数
        <input id="durationSec" class="small" type="number" min="0.1" step="0.1" value="3.0">
      </label>
      <label>書き出しFPS
        <input id="fps" class="small" type="number" min="1" step="1" value="30">
      </label>

      <!-- CC表示トグル（デフォルトOFF） -->
      <label class="label-inline" title="Canvas下のCC表示をON/OFFします（デフォルトOFF）">
        CC表示
        <input id="showCC" type="checkbox">
      </label>

      <button class="primary" id="exportBtn">⬇ 透過PNG連番を書き出し（ZIP）</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="addKnobBtn">＋ ノブ追加</button>
      <button id="downloadJsonBtn">設定JSONを保存</button>
      <label>JSONを読み込み
        <input id="loadJsonInput" type="file" accept="application/json">
      </label>

      <div class="spacer"></div>

      <div class="progress" title="書き出し進捗">
        <div id="progressBar"></div>
      </div>
      <div id="progressText" class="hint" style="min-width:160px; text-align:right;"></div>
    </div>

    <div class="hint" style="margin-top:10px;">
      ・回転幅は -140°〜+140°（合計280°） / 値域は 0〜127（MIDI CC）<br>
      ・Canvas背景は透明です（書き出しPNGも透過）。<br>
      ・CC表示をONにすると、行間（縦方向の余白）を自動的に少し増やし、重なりを防止します。<br>
      ・のちのち「ノブPNG素材」を使う場合は、描画部分だけ差し替えできます。
    </div>

    <div id="knobList" class="knob-list"></div>
  </div>
</div>

<!-- JSZip（ZIP書き出し用） -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
(() => {
  // ---------------------------
  // State
  // ---------------------------
  let state = {
    durationSec: 3.0,
    fps: 30,
    showCC: false, // ★ デフォルトでCC表示OFF
    knobs: [
      { id: crypto.randomUUID(), label: "TONE", text: "", start: 0, end: 127, mode: "normal" },
      { id: crypto.randomUUID(), label: "DIST", text: "", start: 0, end: 70,  mode: "normal" },
    ],
  };

  // Animation runtime snapshot
  let playing = false;
  let startTime = 0;
  let snapshot = null; // { durationMs, knobs:[{start,end,label,text,mode}] }

  // ---------------------------
  // DOM
  // ---------------------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  const playBtn = document.getElementById("playBtn");
  const stopBtn = document.getElementById("stopBtn");
  const resetBtn = document.getElementById("resetBtn");
  const exportBtn = document.getElementById("exportBtn");
  const addKnobBtn = document.getElementById("addKnobBtn");
  const knobListEl = document.getElementById("knobList");

  const durationInput = document.getElementById("durationSec");
  const fpsInput = document.getElementById("fps");

  const showCCCheckbox = document.getElementById("showCC");

  const progressBar = document.getElementById("progressBar");
  const progressText = document.getElementById("progressText");

  const downloadJsonBtn = document.getElementById("downloadJsonBtn");
  const loadJsonInput = document.getElementById("loadJsonInput");

  // ---------------------------
  // Canvas sizing
  // ---------------------------
  function resizeCanvasToCssPixels() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
  }

  // ---------------------------
  // Helpers
  // ---------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;

  function easeInOutCubic(t) {
    t = clamp(t, 0, 1);
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
  }

  // CC(0..127) -> angle degrees within 280deg range.
  // 0 => -140deg (left), 127 => +140deg (right)
  function ccToAngleDeg(cc) {
    const t = clamp(cc, 0, 127) / 127;
    return lerp(-140, 140, t);
  }

  // Angle degrees where 0deg is up (12 o'clock).
  function angleDegToRadForCanvas(degFromUp) {
    const degFromX = degFromUp - 90; // 0(up) -> -90 (canvas x-axis)
    return degFromX * Math.PI / 180;
  }

  function formatFrameName(i, digits=4) {
    return "frame_" + String(i).padStart(digits, "0") + ".png";
  }

  function setProgress(p, text="") {
    const pct = clamp(p, 0, 1) * 100;
    progressBar.style.width = pct.toFixed(1) + "%";
    progressText.textContent = text;
  }

  // ---------------------------
  // Layout & Drawing
  // ---------------------------

  // ★ CC表示ONのときだけ、縦方向の余白（gapY）を増やして重なりを防止
  // labelMaxOffset: ノブ中心から「一番下のテキスト行」までの追加オフセット（rは別）
  function computeLabelMaxOffset() {
    const hasAnyText = state.knobs.some(k => (k.text || "").trim().length > 0);

    // ラベルは常に+24
    // 任意テキストがあれば+42
    // CC表示ONなら+58（CC行が追加されるため）
    if (state.showCC) return 58;
    if (hasAnyText) return 42;
    return 24;
  }

  function computeLayout(width, height, knobCount, labelMaxOffset) {
    const pad = 26;

    const knobRadius = Math.max(34, Math.min(64, Math.floor(Math.min(width, height) / 10)));
    const knobDiameter = knobRadius * 2;

    const gapX = Math.floor(knobRadius * 1.2);

    // 基本のgapY（見栄え）
    let gapY = Math.floor(knobRadius * 1.35);

    // ★ ラベル/テキスト/CCが次の行のノブと干渉しないように最低gapYを確保
    // 目安：gapY >= labelMaxOffset (+少しマージン)
    const margin = 10;
    gapY = Math.max(gapY, labelMaxOffset + margin);

    const usableW = width - pad * 2;
    const cellW = knobDiameter + gapX;
    const cols = Math.max(1, Math.floor((usableW + gapX) / cellW));
    const rows = Math.max(1, Math.ceil(knobCount / cols));

    const totalW = cols * knobDiameter + (cols - 1) * gapX;

    // ★ 最下段だけ「ノブ下のテキスト分(labelMaxOffset)」が追加で必要
    const totalH = rows * knobDiameter + (rows - 1) * gapY + labelMaxOffset;

    const startX = pad + Math.max(0, Math.floor((usableW - totalW) / 2));
    const usableH = height - pad * 2;
    const startY = pad + Math.max(0, Math.floor((usableH - totalH) / 2));

    return { pad, knobRadius, knobDiameter, gapX, gapY, cols, rows, startX, startY, labelMaxOffset };
  }

  function drawKnob(ctx, cx, cy, r, angleDegFromUp, label, text, value) {
    // knob body
    ctx.save();
    ctx.translate(cx, cy);

    // subtle ring
    ctx.beginPath();
    ctx.arc(0, 0, r + 2, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.lineWidth = Math.max(2, r * 0.07);
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.94)";
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.lineWidth = Math.max(1, r * 0.05);
    ctx.stroke();

    // indicator
    const rad = angleDegToRadForCanvas(angleDegFromUp);
    const inner = r * 0.18;
    const outer = r * 0.88;
    ctx.beginPath();
    ctx.moveTo(Math.cos(rad) * inner, Math.sin(rad) * inner);
    ctx.lineTo(Math.cos(rad) * outer, Math.sin(rad) * outer);
    ctx.strokeStyle = "rgba(0,0,0,0.75)";
    ctx.lineWidth = Math.max(2, r * 0.08);
    ctx.lineCap = "round";
    ctx.stroke();

    // center dot
    ctx.beginPath();
    ctx.arc(0, 0, Math.max(2, r * 0.08), 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fill();

    ctx.restore();

    // label + optional text + optional CC
    ctx.save();
    ctx.textAlign = "center";

    // label
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "600 16px system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif";
    ctx.fillText(label || "", cx, cy + r + 24);

    // optional text
    let y = cy + r + 42;
    if (text && text.trim().length) {
      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif";
      ctx.fillText(text.trim(), cx, y);
      y += 16; // 次の行へ
    } else {
      // textがない場合でも、CCは固定位置に置く方が見た目が安定するので
      // CC表示ONなら「58」に揃える
      y = cy + r + 58;
    }

    // optional CC
    if (state.showCC) {
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.font = "11px system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif";
      // textがある場合は y（=58または58近辺）に、ない場合も58に
      const ccY = (text && text.trim().length) ? (cy + r + 58) : (cy + r + 58);
      ctx.fillText("CC " + Math.round(value), cx, ccY);
    }

    ctx.restore();
  }

  function drawScene(progress01, targetCtx = ctx, targetCanvas = canvas) {
    const w = targetCanvas.width;
    const h = targetCanvas.height;

    // transparent background
    targetCtx.clearRect(0, 0, w, h);

    const labelMaxOffset = computeLabelMaxOffset();
    const layout = computeLayout(w, h, state.knobs.length, labelMaxOffset);
    const easeT = easeInOutCubic(progress01);

    // subtle caption
    targetCtx.save();
    targetCtx.fillStyle = "rgba(255,255,255,0.20)";
    targetCtx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans JP', sans-serif";
    targetCtx.textAlign = "left";
    targetCtx.fillText("Knob Animation Preview (transparent)", layout.pad, layout.pad - 8);
    targetCtx.restore();

    for (let i = 0; i < state.knobs.length; i++) {
      const k = state.knobs[i];
      const row = Math.floor(i / layout.cols);
      const col = i % layout.cols;

      const cx = layout.startX + col * (layout.knobDiameter + layout.gapX) + layout.knobRadius;
      const cy = layout.startY + row * (layout.knobDiameter + layout.gapY) + layout.knobRadius;

      const s = clamp(Number(k.start) || 0, 0, 127);
      const e = clamp(Number(k.end) || 0, 0, 127);
      const v = lerp(s, e, easeT);

      const ang = ccToAngleDeg(v);
      drawKnob(targetCtx, cx, cy, layout.knobRadius, ang, k.label, k.text, v);
    }
  }

  // ---------------------------
  // UI render
  // ---------------------------
  function renderKnobList() {
    knobListEl.innerHTML = "";
    state.knobs.forEach((k, idx) => {
      const card = document.createElement("div");
      card.className = "knob-card";

      const header = document.createElement("div");
      header.className = "header";

      const title = document.createElement("div");
      title.className = "title";
      title.textContent = `ノブ ${idx + 1}`;

      const delBtn = document.createElement("button");
      delBtn.className = "danger";
      delBtn.textContent = "削除";
      delBtn.onclick = () => {
        state.knobs = state.knobs.filter(x => x.id !== k.id);
        renderKnobList();
        requestDraw();
      };

      header.appendChild(title);
      header.appendChild(delBtn);

      const row1 = document.createElement("div");
      row1.className = "row";

      const labelInput = document.createElement("input");
      labelInput.type = "text";
      labelInput.value = k.label || "";
      labelInput.placeholder = "ラベル（例：TONE）";
      labelInput.oninput = (e) => { k.label = e.target.value; requestDraw(); };

      const textInput = document.createElement("input");
      textInput.type = "text";
      textInput.value = k.text || "";
      textInput.placeholder = "任意テキスト（小さく表示）";
      textInput.oninput = (e) => { k.text = e.target.value; requestDraw(); };

      row1.appendChild(wrapLabeled("ラベル", labelInput));
      row1.appendChild(wrapLabeled("任意テキスト", textInput));

      const row2 = document.createElement("div");
      row2.className = "row";

      const startInput = document.createElement("input");
      startInput.type = "number"; startInput.min = "0"; startInput.max = "127"; startInput.step = "1";
      startInput.value = k.start;
      startInput.oninput = (e) => { k.start = clamp(Number(e.target.value || 0), 0, 127); requestDraw(); };

      const endInput = document.createElement("input");
      endInput.type = "number"; endInput.min = "0"; endInput.max = "127"; endInput.step = "1";
      endInput.value = k.end;
      endInput.oninput = (e) => { k.end = clamp(Number(e.target.value || 0), 0, 127); requestDraw(); };

      const modeSel = document.createElement("select");
      modeSel.innerHTML = `
        <option value="normal">通常（0→127）</option>
        <option value="center">センター型（64が中心）</option>
      `;
      modeSel.value = k.mode || "normal";
      modeSel.onchange = (e) => { k.mode = e.target.value; requestDraw(); };

      row2.appendChild(wrapLabeled("Start (0-127)", startInput));
      row2.appendChild(wrapLabeled("End (0-127)", endInput));
      row2.appendChild(wrapLabeled("タイプ", modeSel));

      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = "※このプロトタイプでは、センター型も回転マッピングは同じです（64付近が自然に中央）。必要なら後で“64=真上(12時)”固定などにできます。";

      card.appendChild(header);
      card.appendChild(row1);
      card.appendChild(row2);
      card.appendChild(hint);
      knobListEl.appendChild(card);
    });
  }

  function wrapLabeled(labelText, controlEl) {
    const lab = document.createElement("label");
    lab.textContent = labelText;
    lab.appendChild(controlEl);
    return lab;
  }

  // ---------------------------
  // Animation loop
  // ---------------------------
  let drawRequested = false;
  function requestDraw() {
    if (drawRequested) return;
    drawRequested = true;
    requestAnimationFrame(() => {
      drawRequested = false;
      resizeCanvasToCssPixels();
      if (!playing) drawScene(0);
    });
  }

  function play() {
    if (playing) return;

    snapshot = {
      durationMs: clamp(Number(state.durationSec) || 3, 0.1, 999) * 1000,
      knobs: state.knobs.map(k => ({
        start: clamp(Number(k.start) || 0, 0, 127),
        end: clamp(Number(k.end) || 0, 0, 127),
        label: k.label || "",
        text: k.text || "",
        mode: k.mode || "normal",
      }))
    };

    playing = true;
    startTime = performance.now();
    loop();
  }

  function stop() {
    playing = false;
    snapshot = null;
  }

  function reset() {
    stop();
    requestDraw();
  }

  function loop() {
    if (!playing || !snapshot) return;

    resizeCanvasToCssPixels();

    const now = performance.now();
    const t = (now - startTime) / snapshot.durationMs;
    const p = clamp(t, 0, 1);

    // draw using snapshot values (deterministic)
    const saved = state.knobs;
    state.knobs = state.knobs.map((k, i) => ({
      ...k,
      start: snapshot.knobs[i]?.start ?? k.start,
      end: snapshot.knobs[i]?.end ?? k.end,
      label: snapshot.knobs[i]?.label ?? k.label,
      text: snapshot.knobs[i]?.text ?? k.text,
      mode: snapshot.knobs[i]?.mode ?? k.mode,
    }));
    drawScene(p);
    state.knobs = saved;

    if (p >= 1) {
      playing = false;
      snapshot = null;
      return;
    }
    requestAnimationFrame(loop);
  }

  // ---------------------------
  // Export: PNG sequence ZIP (transparent)
  // ---------------------------
  async function exportPngZip() {
    if (!window.JSZip) {
      alert("JSZipが読み込めていません（オフラインの場合など）。CDN接続を確認してください。");
      return;
    }

    const durationSec = clamp(Number(state.durationSec) || 3, 0.1, 999);
    const fps = clamp(Number(state.fps) || 30, 1, 240);
    const frames = Math.max(2, Math.round(durationSec * fps) + 1); // include last frame

    // Offscreen canvas with same pixel size as preview
    resizeCanvasToCssPixels();
    const off = document.createElement("canvas");
    off.width = canvas.width;
    off.height = canvas.height;
    const offCtx = off.getContext("2d", { alpha:true });

    // Freeze snapshot for export
    const exportSnapshot = {
      durationSec,
      fps,
      showCC: state.showCC,
      knobs: state.knobs.map(k => ({
        start: clamp(Number(k.start) || 0, 0, 127),
        end: clamp(Number(k.end) || 0, 0, 127),
        label: k.label || "",
        text: k.text || "",
        mode: k.mode || "normal",
      }))
    };

    const zip = new JSZip();
    setUiDisabled(true);
    setProgress(0, `書き出し準備中... (0/${frames})`);

    try {
      for (let i = 0; i < frames; i++) {
        const p = i / (frames - 1);

        // draw with exportSnapshot values
        const savedKnobs = state.knobs;
        const savedShowCC = state.showCC;

        state.showCC = exportSnapshot.showCC;
        state.knobs = savedKnobs.map((k, idx) => ({
          ...k,
          start: exportSnapshot.knobs[idx].start,
          end: exportSnapshot.knobs[idx].end,
          label: exportSnapshot.knobs[idx].label,
          text: exportSnapshot.knobs[idx].text,
          mode: exportSnapshot.knobs[idx].mode,
        }));

        drawScene(p, offCtx, off);

        state.knobs = savedKnobs;
        state.showCC = savedShowCC;

        const blob = await new Promise(resolve => off.toBlob(resolve, "image/png"));
        zip.file(formatFrameName(i, 4), blob);

        setProgress((i + 1) / frames, `PNG生成中... (${i + 1}/${frames})`);
        await new Promise(r => setTimeout(r, 0));
      }

      setProgress(1, "ZIP生成中...");
      const zipBlob = await zip.generateAsync({ type: "blob" }, (meta) => {
        setProgress(1, `ZIP生成中... (${meta.percent.toFixed(0)}%)`);
      });

      const stamp = new Date().toISOString().replace(/[:.]/g, "-");
      downloadBlob(zipBlob, `knob_png_sequence_${stamp}.zip`);
      setProgress(1, "完了（ZIPをダウンロードしました）");
    } catch (e) {
      console.error(e);
      alert("書き出し中にエラーが発生しました。コンソールを確認してください。");
      setProgress(0, "エラー");
    } finally {
      setUiDisabled(false);
    }
  }

  function setUiDisabled(disabled) {
    [playBtn, stopBtn, resetBtn, exportBtn, addKnobBtn, durationInput, fpsInput, showCCCheckbox, downloadJsonBtn, loadJsonInput]
      .forEach(el => el.disabled = disabled);
    knobListEl.querySelectorAll("button").forEach(btn => btn.disabled = disabled);
  }

  function downloadBlob(blob, filename) {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(a.href);
      a.remove();
    }, 1000);
  }

  // ---------------------------
  // Save/Load JSON
  // ---------------------------
  function downloadJson() {
    const data = {
      version: 1,
      durationSec: state.durationSec,
      fps: state.fps,
      showCC: state.showCC,
      knobs: state.knobs,
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const stamp = new Date().toISOString().replace(/[:.]/g, "-");
    downloadBlob(blob, `knob_settings_${stamp}.json`);
  }

  async function loadJsonFile(file) {
    const text = await file.text();
    const data = JSON.parse(text);
    if (!data || !Array.isArray(data.knobs)) throw new Error("Invalid JSON");

    state.durationSec = Number(data.durationSec ?? 3);
    state.fps = Number(data.fps ?? 30);
    state.showCC = !!data.showCC;

    state.knobs = data.knobs.map(k => ({
      id: k.id || crypto.randomUUID(),
      label: String(k.label ?? ""),
      text: String(k.text ?? ""),
      start: clamp(Number(k.start ?? 0), 0, 127),
      end: clamp(Number(k.end ?? 0), 0, 127),
      mode: (k.mode === "center" ? "center" : "normal"),
    }));

    durationInput.value = state.durationSec;
    fpsInput.value = state.fps;
    showCCCheckbox.checked = state.showCC;

    renderKnobList();
    requestDraw();
  }

  // ---------------------------
  // Events
  // ---------------------------
  playBtn.onclick = () => play();
  stopBtn.onclick = () => stop();
  resetBtn.onclick = () => reset();

  addKnobBtn.onclick = () => {
    state.knobs.push({ id: crypto.randomUUID(), label: "NEW", text:"", start: 0, end: 127, mode: "normal" });
    renderKnobList();
    requestDraw();
  };

  durationInput.oninput = (e) => {
    state.durationSec = clamp(Number(e.target.value || 3), 0.1, 999);
  };
  fpsInput.oninput = (e) => {
    state.fps = clamp(Number(e.target.value || 30), 1, 240);
  };

  showCCCheckbox.onchange = (e) => {
    state.showCC = !!e.target.checked;
    requestDraw(); // ★ CCのON/OFFでレイアウトも変わるので再描画
  };

  exportBtn.onclick = () => exportPngZip();

  downloadJsonBtn.onclick = () => downloadJson();
  loadJsonInput.onchange = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try { await loadJsonFile(file); }
    catch (err) { alert("JSON読み込みに失敗しました: " + err.message); }
    finally { e.target.value = ""; }
  };

  window.addEventListener("resize", () => requestDraw());

  // ---------------------------
  // Init
  // ---------------------------
  durationInput.value = state.durationSec;
  fpsInput.value = state.fps;
  showCCCheckbox.checked = state.showCC;

  renderKnobList();
  requestDraw();
  setProgress(0, "");
})();
</script>
</body>
</html>
